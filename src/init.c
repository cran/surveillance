/*******************************************************************************
// Registering native routines (entry points in compiled code)
// 
// Based on code generated by
// R-4.0.3> tools::package_native_routine_registration_skeleton("..", character_only = FALSE)
// for surveillance 1.19.1
// + adding R_forceSymbols(dll, TRUE);
// + adding function declarations via cproto -I/usr/share/R/include -e *.c
*******************************************************************************/

#include <R.h>
#include <Rinternals.h>
#include <stdlib.h> // for NULL
#include <R_ext/Rdynload.h>

/* .C calls */
extern void glr_cusum(int *x, double *mu0, int *lx_R, int *n0_R, double *c_ARL_R, int *ret_N, double *ret_glr, double *ret_cases, int *dir_R, int *ret_R);
extern void glr_cusum_window(int *x, double *mu0, int *lx_R, int *M_R, int *Mtilde_R, double *c_ARL_R, int *ret_N, double *ret_glr, double *ret_cases, int *dir_R, int *ret_R);
extern void glr_epi_window(int *x, double *mu0, int *lx_R, int *Mtilde_R, int *M_R, double *xm10, double *c_ARL_R, int *ret_N, double *ret_glr);
extern void glr_nbgeneral_window(int *x, double *mu0, double *alpha_R, int *lx_R, int *Mtilde_R, int *M_R, double *xm10, double *c_ARL_R, int *ret_N, double *ret_glr, int *dir_R);
extern void glr_nb_window(int *x, double *mu0, double *alpha_R, int *lx_R, int *Mtilde_R, int *M_R, double *c_ARL_R, int *ret_N, double *ret_glr, int *dir_R);
extern void lr_cusum(int *x, double *mu0, int *lx_R, double *kappa_R, double *c_ARL_R, int *ret_N, double *ret_lr, double *ret_cases, int *ret_R);
extern void lr_cusum_nb(int *x, double *mu0, double *alpha_R, int *lx_R, double *kappa_R, double *c_ARL_R, int *ret_N, double *ret_lr, double *ret_cases, int *ret_R);
extern void siaf_polyCub1_iso(double *x, double *y, int *L, int *intrfr_code, double *pars, int *subdivisions, double *epsabs, double *epsrel, int *stop_on_error, double *value, double *abserr, int *neval);

extern void SRspacetime(double *x, double *y, double *t, int *n, double *radius,
                        double *epsilon, double *areaA, double *areaAcapBk,
                        int *cusum, double *threshold, 
                        double *Rarray, int *idxFirstAlarm, int *idxClusterCenter);

/* .Call calls */
extern SEXP determineSources(SEXP, SEXP, SEXP, SEXP, SEXP, SEXP, SEXP);
extern SEXP eq3a(SEXP, SEXP, SEXP);
extern SEXP pKS2(SEXP, SEXP);
extern SEXP pKolmogorov2x(SEXP, SEXP);

static const R_CMethodDef CEntries[] = {
    {"glr_cusum",            (DL_FUNC) &glr_cusum,            10},
    {"glr_cusum_window",     (DL_FUNC) &glr_cusum_window,     11},
    {"glr_epi_window",       (DL_FUNC) &glr_epi_window,        9},
    {"glr_nbgeneral_window", (DL_FUNC) &glr_nbgeneral_window, 11},
    {"glr_nb_window",        (DL_FUNC) &glr_nb_window,        10},
    {"lr_cusum",             (DL_FUNC) &lr_cusum,              9},
    {"lr_cusum_nb",          (DL_FUNC) &lr_cusum_nb,          10},
    {"siaf_polyCub1_iso",    (DL_FUNC) &siaf_polyCub1_iso,    12},
    {"SRspacetime",          (DL_FUNC) &SRspacetime,          13},
    {NULL, NULL, 0}
};

static const R_CallMethodDef CallEntries[] = {
    {"determineSources", (DL_FUNC) &determineSources, 7},
    {"eq3a",             (DL_FUNC) &eq3a,             3},
    {"pKS2",             (DL_FUNC) &pKS2,             2},
    {"pKolmogorov2x",    (DL_FUNC) &pKolmogorov2x,    2},
    {NULL, NULL, 0}
};

void R_init_surveillance(DllInfo *dll)
{
    R_registerRoutines(dll, CEntries, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
    R_forceSymbols(dll, TRUE);
}
